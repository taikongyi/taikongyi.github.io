{"pages":[{"title":"About","date":"2020-08-20T05:44:37.658Z","path":"about/index.html","text":""},{"title":"Categories","date":"2020-08-20T05:44:37.659Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2020-08-20T05:44:37.661Z","path":"tags/index.html","text":""}],"posts":[{"title":"计算机原理与网络","date":"2020-08-09T05:03:36.000Z","path":"wiki/计算机原理与网络/","text":"参考资料","tags":[],"categories":[]},{"title":"优化-性能优化","date":"2020-07-24T16:00:00.000Z","path":"wiki/优化-性能优化/","text":"前端性能优化12345678910111213141516171819202122232425261、加载优化 静态资源加载优化，cdn or oss 尽可能少的加载外联css、js代码，html头部，增加dsn-preftch，减少dns解析时间 压缩css js pic，减小体积，服务端开启gzip压缩 控制http请求 js加载脚本阻塞浏览器主线程，考虑异步， 如 async 利用好缓存，利用好http响应头缓存字段，开启静态资源缓存 2、浏览器渲染 css层不要太深，避免最内层使用统配选择器 js脚本不要太复杂，减少js解析时间，少引用复杂的第三方脚本 模块按需加载，按需打包，首页仅仅加载和执行和首屏相关的脚本，其他脚本延迟加载 第三方包需不需 要精简 打包优化，code split webpack3，缓存 内存 响应资源放入内存，直接读取，无需线程转换， 消耗资源 客户端缓存 HTTp缓存 catche-control与服务器进行数据协商，根据标准缓存活着更新资源 网络相关的缓存 一般指dns解析结果的缓存或者预连接缓存，创建一个https成本很大 cdn 根据用户ip地址及请求的url选择一台距离用户比较近的资源缩短路径，提升性能 localstorage缓存html文档首次访问页面时，js执行完后会生成完整的html文档，缓存到localstorage里面 浏览器js占用大量时间LINUX命令将一个文件夹里面的所有文件复制到指定文件里 cp -r /root/XXX/Account/. /ftp/ZJNX","tags":[{"name":"性能优化 浏览器渲染 缓存","slug":"性能优化-浏览器渲染-缓存","permalink":"http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93-%E7%BC%93%E5%AD%98/"}],"categories":[{"name":"优化","slug":"优化","permalink":"http://yoursite.com/categories/%E4%BC%98%E5%8C%96/"}]},{"title":"vue中key的作用总结","date":"2020-06-19T16:00:00.000Z","path":"wiki/vue中key的作用总结/","text":"vue 中 key 的作用 总结：12345key的作用主要是为了高效的更新虚拟dom 没有加key，diff默认算法的问题（虚拟dom） 1. 如果节点类型不同，直接干掉前面所有的节点，再创建并插入新的节点，不会再比较这个节点以后的子节点 2. 如果节点类型相同，则会重新设置节点的属性，从而实现节点的更新","tags":[{"name":"Vue key","slug":"Vue-key","permalink":"http://yoursite.com/tags/Vue-key/"}],"categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"基础","slug":"Vue/基础","permalink":"http://yoursite.com/categories/Vue/%E5%9F%BA%E7%A1%80/"}]},{"title":"linux-常用命令","date":"2020-05-01T16:00:00.000Z","path":"wiki/Linux-常用命令/","text":"复制文件 到另一个文件夹将一个文件夹里面的所有文件复制到指定文件里1cp -r /root/XXX/Account/. /ftp/ZJNX","tags":[{"name":"linux基础 常用命令","slug":"linux基础-常用命令","permalink":"http://yoursite.com/tags/linux%E5%9F%BA%E7%A1%80-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"}],"categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"},{"name":"命令","slug":"Linux/命令","permalink":"http://yoursite.com/categories/Linux/%E5%91%BD%E4%BB%A4/"}]},{"title":"Laravel-CURD小结","date":"2020-03-02T13:35:37.000Z","path":"wiki/PHP-Laravel-CURD小结/","text":"Laravel-CURD小结1.curd思路设计表格式文章列表 id 标题， 内容，类型（类型i的）， 简介， 作者 文章类型：1新闻，2科技，3社会，4自然，5教育 2.建立 模型，php artisan make:model Models\\Article -a -a 创建所有 模型 迁移表 控制器 3.设计数据表并迁移到数据库 在database/migrate 文件夹 php artisan migrate(在数据库生成一个数据表) 4.设计数据表的模拟数据格式，生成模拟数据方法一 factory =》faker 命令 php artisan tinker factory助手函数factory(App\\Models\\Article::class, 5)-&gt;make(); factory(App\\Models\\Article::class, 5)-&gt;create(); 方法二 seeder php artisan make:seeder ArtTypesTableSeeder 生成类 ---&gt;查询构造器填数据 ---&gt;填充 php artisan db:seed(执行DatabaseSeeder.php)(手动执行 php artisan db:seed --class=*** 具体执行某一个填充类) 5.设置模型属性，详情见模型 1.定义主键 表名称 可填充数据的字段 protected $primaryKey=&#39;id&#39;; protected $table=&#39;articles&#39;; protected $fillable = [&#39;title&#39;,&#39;content&#39;,&#39;category_id&#39;,&#39;introduction&#39;, &#39;author&#39;]; 2 .定义表的关联关系 两个关联表要同时定义关联关系， 可在php artisan tinker 里面做验证【类似sql语句， 程序里能写的都可以在这里做验证，相当于一个交互式的环境】 6.设置资源路由7.控制器 视图编写相关代码create—-storeedit——–update","tags":[{"name":"PHP 框架 Laravel","slug":"PHP-框架-Laravel","permalink":"http://yoursite.com/tags/PHP-%E6%A1%86%E6%9E%B6-Laravel/"}],"categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"},{"name":"框架","slug":"PHP/框架","permalink":"http://yoursite.com/categories/PHP/%E6%A1%86%E6%9E%B6/"},{"name":"Laravel","slug":"PHP/框架/Laravel","permalink":"http://yoursite.com/categories/PHP/%E6%A1%86%E6%9E%B6/Laravel/"}]},{"title":"JavaScript-跨域","date":"2019-09-28T16:00:00.000Z","path":"wiki/JavaScript-跨域/","text":"跨域 不同域名 不同端口 不同协议 不同域名 proxy 代理 jsonp 后端配置(常用)","tags":[{"name":"JavaScript 基础知识 跨域","slug":"JavaScript-基础知识-跨域","permalink":"http://yoursite.com/tags/JavaScript-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%B7%A8%E5%9F%9F/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"基础","slug":"JavaScript/基础","permalink":"http://yoursite.com/categories/JavaScript/%E5%9F%BA%E7%A1%80/"}]},{"title":"Jquery和vue区别","date":"2019-09-27T16:00:00.000Z","path":"wiki/Jquery和vue区别/","text":"jquery和vue区别 jq侧重于视图层，通过dom去实现页面的逻辑渲染 vue侧重于数据层，通过双向绑定最终表现在dom，减少了dom操作 vue优势，组件化，提高了效率，方便重复使用，便于协同开发","tags":[{"name":"JavaScript 基础知识 jq vue","slug":"JavaScript-基础知识-jq-vue","permalink":"http://yoursite.com/tags/JavaScript-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-jq-vue/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"基础","slug":"JavaScript/基础","permalink":"http://yoursite.com/categories/JavaScript/%E5%9F%BA%E7%A1%80/"}]},{"title":"JavaScript-闭包","date":"2019-09-24T16:00:00.000Z","path":"wiki/JavaScript-闭包/","text":"闭包的作用一个函数可以访问外部函数的内部变量，构成一个闭包环境(函数嵌套 引用外部函数变量， 内部函数有一个对象，存储外部被引用的变量)12闭包的生命周期：在嵌套的内部函数成为垃圾对象时也就是不再被引用 闭包作用123451. 变量维持的内存中2. 保护内部变量，以防造成污染 - 但是会造成内存泄露 使用场景—自定义js模块123开发中经常用到的函数，格式化时间日期的，判断是否是数字的等等，封装到一个模块里面， 在需要使用的地方引入。不能直接访问内部的东西，但是可以通过暴露接口给外部，操作内部的数据 代码示例123456789101112131415161718192021&lt;script&gt; function fun(n, o) &#123; console.log(o); return &#123; fun:function(m) &#123; return fun(m, n); &#125; &#125; &#125; // var b = fun(0).fun(1).fun(2).fun(3); //0 1 2 // m1no n 1 o 0 m 2 n 1 n 2 o 1 m 3 n 2 n 3 o 2 // var a = fun(0); // a.fun(1);//m 1 n 0 // a.fun(2); // m2 n 0 // a.fun(3); //m 3 n 0 var c = fun(0).fun(1); // m 1 n 0 n 1 o 0 c.fun(2); // m 2 n 1 n 2 o 1 c.fun(3); // m 3 n 1 n 3 o 1 闭包的缺点123函数执行完后，函数内部局部变量没有释放，占用内存时间会边长容易造成内存泄露***解决---及时释放内存结束生命===== f=null 闭包的暴力理解12345678910在使用闭包时候，当函数执行完，用一个新的引入变量，去接受内部函数返回的函数对象，闭包就在函数对象里面形成了， 作用就是 延长了外部函数变量的生命周期，以及内部函数对象的生命周期。如果没有引入变量是不会占用内存的，产生了 又放走了。结合截屏 看。。。对象的引用+垃圾回收机制函数在 那个对象里面调用，this就指向那个对象。 图解","tags":[{"name":"JavaScript 基础知识 闭包","slug":"JavaScript-基础知识-闭包","permalink":"http://yoursite.com/tags/JavaScript-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E9%97%AD%E5%8C%85/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"基础","slug":"JavaScript/基础","permalink":"http://yoursite.com/categories/JavaScript/%E5%9F%BA%E7%A1%80/"}]},{"title":"vue单页面应用的优缺点","date":"2019-08-30T16:00:00.000Z","path":"wiki/vue单页面应用的优缺点/","text":"单页面应用的优缺点 单页面的优点：123451. 用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小 2. 前后端分离 3. 页面效果会比较炫酷（比如切换页面内容时的专场动画） 单页面的缺点 1234567891. 不利于seo 2. 导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理） 3. 初次加载时耗时多 4. 页面复杂度提高很多","tags":[{"name":"Vue 单页面应用 优缺点","slug":"Vue-单页面应用-优缺点","permalink":"http://yoursite.com/tags/Vue-%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8-%E4%BC%98%E7%BC%BA%E7%82%B9/"}],"categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"基础","slug":"Vue/基础","permalink":"http://yoursite.com/categories/Vue/%E5%9F%BA%E7%A1%80/"}]},{"title":"vue的样式穿透","date":"2019-08-30T16:00:00.000Z","path":"wiki/vue的样式穿透/","text":"vue深度作用域vue有 在有作用域样式的组建中，默认只能对作用域组件的根节点进行生效1234567891011121314&lt;根组件&gt; &lt;子组件&gt; &lt;子子组件&gt; &lt;/子子组件 class=&quot;a&quot;&gt; &lt;/子组件&gt;&lt;/根组件&gt;此时 样式a只能作用在根节点组件,要想作用在子组件可用以下解决办法。1.脱离作用域，去掉scoped 但是容易和其他组件样式冲突2. /deep/` 或者 `::v-deep` &gt;&gt;&gt;详细见文档----&gt; loader ---&gt;作用域样式 深度作用域 123456/deep/ .abc &#123; position: fixed; margin：10px; padding: 20px;&#125;","tags":[{"name":"Vue 样式穿透 深度作用域","slug":"Vue-样式穿透-深度作用域","permalink":"http://yoursite.com/tags/Vue-%E6%A0%B7%E5%BC%8F%E7%A9%BF%E9%80%8F-%E6%B7%B1%E5%BA%A6%E4%BD%9C%E7%94%A8%E5%9F%9F/"}],"categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"基础","slug":"Vue/基础","permalink":"http://yoursite.com/categories/Vue/%E5%9F%BA%E7%A1%80/"}]},{"title":"JavaScript-箭头函数与普通函数的区别","date":"2019-08-24T16:00:00.000Z","path":"wiki/JavaScript-箭头函数与普通函数的区别/","text":"箭头函数与普通函数的区别123- 内部没有arguments- 内部没有this- 不能作为构造器 写法区别1234567891011121314151617181920212223es5 写法var show = function (x) &#123; return &#x27;es5&#x27;&#125;es6写法 show是变量let show = (x) =&gt; &#123; return &#x27;es6&#x27;&#125;唯且仅有只有一个参数的时候()可以省略let show = x =&gt; return &#123; &#x27;es6&#x27;&#125;当只有return一行的时候，可以省略return，&#123;&#125;let add = (a,b) =&gt; a+b 函数参数不确定123456789101112131415161718es5 写法arguments是伪数组，转化为数组，Array.from(arguments)或者Array.prototype.slice.apply(arguments)，将他转化数组function show() &#123; console.log(arguments)&#125;es6写法 function show(...arg)&#123; console.log(arg);//arg是一个数组 &#125; or let show = (...arg)=&gt; console.log(arg) 函数值默认12345let show(a, b=1, c=3) =&gt; console.log(a+b+c)show(0); //3show(0,2) //4show(0,2,3) //5 小例子123456789101112例子一:function m() &#123; return function(n)&#123; return m+n &#125;&#125;箭头函数写法let m =&gt; n =&gt; m+n 非常简洁 遗留问题1什么是函数柯里化","tags":[{"name":"JavaScript 基础知识 函数 箭头函数","slug":"JavaScript-基础知识-函数-箭头函数","permalink":"http://yoursite.com/tags/JavaScript-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%87%BD%E6%95%B0-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"基础","slug":"JavaScript/基础","permalink":"http://yoursite.com/categories/JavaScript/%E5%9F%BA%E7%A1%80/"}]},{"title":"vue项目是打包及生成的文件","date":"2019-08-23T16:00:00.000Z","path":"wiki/vue项目是打包及生成的文件/","text":"vue项目是打包了一个js文件，一个css文件 1234 根据vue-cli脚手架规范，一个js文件，一个CSS文件。 在打包之前 1.代理的url 2.build assetsPublicPath: &#39;.&#x2F;&#39;","tags":[{"name":"Vue 基础知识 项目打包","slug":"Vue-基础知识-项目打包","permalink":"http://yoursite.com/tags/Vue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/"}],"categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"基础","slug":"Vue/基础","permalink":"http://yoursite.com/categories/Vue/%E5%9F%BA%E7%A1%80/"}]},{"title":"Mysql远程连接失败解决方案","date":"2019-08-02T08:58:34.000Z","path":"wiki/Mysql-远程连接失败解决方案/","text":"今天编译安装mysql, Navicate远程连接失败,整理以下解决方案12341.安全组 开放端口2.防火墙 开放端口3. mysql 配置 bind 00004.开放权限 修改mysql user表中 root 远程连接权限 在8.0以前，我们习惯使用以下命令授权远程连接操作：123grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27;;但在8.0以后，使用以上命令会报错ERROR 1410 (42000): You are not allowed to create a user with GRANT 使用以下命令可以成功，但无法远程登陆：1234567grant all on *.* to &#x27;root&#x27;@&#x27;%&#x27;;此时，可以使用以下2种方式，实现远程：-- 1. 使用alter useralter user set user.host=&#x27;%&#x27; where user.user=&#x27;root&#x27;;-- 2. 使用create usercreate user &#x27;userName&#x27;@&#x27;%&#x27; identified &#x27;your_password&#x27;; 重要 flushprivileges 别忘记","tags":[{"name":"mysql基础 远程连接","slug":"mysql基础-远程连接","permalink":"http://yoursite.com/tags/mysql%E5%9F%BA%E7%A1%80-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"}],"categories":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/categories/mysql/"},{"name":"基础","slug":"mysql/基础","permalink":"http://yoursite.com/categories/mysql/%E5%9F%BA%E7%A1%80/"}]},{"title":"vue中NextTick是做什么的","date":"2019-07-11T16:00:00.000Z","path":"wiki/vue中NextTick是做什么的/","text":"NextTick 是做什么的123456说明： $nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick， 则可以在回调中获取更新后的 DOM。 场景： 需要在视图更新之后，基于新的视图进行操作使用swiper axios请求数据， 数据（图片）","tags":[{"name":"Vue NextTick","slug":"Vue-NextTick","permalink":"http://yoursite.com/tags/Vue-NextTick/"}],"categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"基础","slug":"Vue/基础","permalink":"http://yoursite.com/categories/Vue/%E5%9F%BA%E7%A1%80/"}]},{"title":"vue-router动态路由的定义","date":"2019-03-01T16:00:00.000Z","path":"wiki/vue-router动态路由的定义/","text":"怎么定义vue-router的动态路由在router目录下的index.js文件中，对path属性加上/:id 怎么获取传过来的动态参数？ 使用router对象的params.id","tags":[{"name":"Vue 动态路由","slug":"Vue-动态路由","permalink":"http://yoursite.com/tags/Vue-%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/"}],"categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"基础","slug":"Vue/基础","permalink":"http://yoursite.com/categories/Vue/%E5%9F%BA%E7%A1%80/"}]},{"title":"vue双向绑定原理","date":"2019-02-14T16:00:00.000Z","path":"wiki/vue双向绑定原理/","text":"Vue的双向数据绑定原理是什么？12345678910111213141516view 更新data 可以通过事件监听，关键 data 如何更新view呢？通过Object.defineProperty()对属性设置一个set函数，当数据改变了，就会 触发这个函数，所以只要将一些需要更新的方法放在这里面，就能实现data更新view了 1. 实现一个监听器Observer，用来劫持监听所有属性，如果有变动，通知订阅者2. 实现一个订阅者watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图 3. 实现一个解析器Compile，可以扫描和解析每个节点相关指令，初始化末班数据以及初始化相应的订阅者监听器 observer ===》 订阅者 watcherCompile 解析器 ===解析相关指令===》wachter watcher ===更新===》view 12345678总计：vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。 1.为什么会多出这两个方法呢？ 因为vue是通过Object.defineProperty()来实现数据劫持的。 2.Object.defineProperty( )是用来做什么的？ 它可以来控制一个对象属性的一些特有操作，比如读写权、是否可以枚举，这里我们主要先来研究下它对应的两个描述属性get和set。 Object.defineProperty(对象,属性,&#123; get()&#123;&#125;, set()&#123;&#125; &#125;)","tags":[{"name":"Vue 双向绑定","slug":"Vue-双向绑定","permalink":"http://yoursite.com/tags/Vue-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"}],"categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"基础","slug":"Vue/基础","permalink":"http://yoursite.com/categories/Vue/%E5%9F%BA%E7%A1%80/"}]},{"title":"JavaScript-面向对象","date":"2018-10-24T16:00:00.000Z","path":"wiki/JavaScript-面向对象/","text":"JS面向对对象对象的创建1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081. Object 构造函数模式 套路：先创建空object对象，再动态添加属性方法 适用场景：其初时候不确定对象内部数据 js 内置对象 var obj = new Obj(); obj.name = 张三 问题： 语句太多 var obj = new Obj(); obj.name = &#x27;张三&#x27; obj.age = 40 obj.setName = function()&#123; this.name = name &#125; console.log(obj.name, obj.age) 2. 对象字面量模式 使用&#123;&#125;创建对象，同时指定属性/方法 适用场景：起始时对象内部数据是确定的 问题：如果创建多个对象，有重复代码 var obj = &#123; name: &#x27;jack&#x27;, age: 30, setName: function()&#123; this.name = name &#125; &#125; obj.setName(&#x27;hanmeimei&#x27;) console.log(obj)3. 工厂模式通过工厂函数动态创建对象并返回适用场景：需要创建多个对象问题：对象没有一个具体的类型，都是Object类型function createTeacher(name,age,major)&#123; var obj = &#123; name:name, age:age, major:major, setName: function(name)&#123; this.name= name &#125; &#125; return obj;&#125;var p1 = createPerson(&#x27;zhangsna&#x27;, 30, &#x27;it&#x27;);var p2 = createPerson(&#x27;lisi&#x27;, 45, &#x27;trade&#x27;);function createStudent(name,age,major)&#123; var obj = &#123; name:name, age:age, major:major, setName: function(name)&#123; this.name= name &#125; &#125; return obj;&#125;只知道创造了一个对象 无法判断 对象之间的区别 属于学生还是teacher4. 自定义构造函数模式套路：自定义构造函数，通过new创建对象适用场景：需要创建多个类型确定的对象问题：每个对象都有相同的数据，浪费内存function Student(name, age, major)&#123; name:name, age:age, major:major, setName: function(name)&#123; this.name= name &#125; &#125;function Teacher(name, age, major)&#123; name:name, age:age, major:major, setName: function(name)&#123; this.name= name &#125; &#125;var p1 = new Student(&#x27;zang&#x27;, 30, &#x27;dazhuan&#x27;);var t1 = new Teacher(&#x27;xiaoli&#x27;, 40, &#x27;qinghua&#x27;); 每个实例都有相同的 属性方法，造成内存的浪费5. 构造函数 + 原型 的组合模式自定义构造函数，属性在函数中初始化，方法添加到原型上适用场景：需要创建多个类型确定的对象 1函数原型 ==&gt; Obj ===&gt; null","tags":[{"name":"JavaScript 基础知识 面向对象 对象创建","slug":"JavaScript-基础知识-面向对象-对象创建","permalink":"http://yoursite.com/tags/JavaScript-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"基础","slug":"JavaScript/基础","permalink":"http://yoursite.com/categories/JavaScript/%E5%9F%BA%E7%A1%80/"}]},{"title":"vue中插件使用","date":"2018-09-18T16:00:00.000Z","path":"wiki/vue中插件使用/","text":"Vue 中 插件使用1231. 下载 npm install xxx2. 引入 import xx from &#x27;xxxx&#x27; Vue.use(xxx)3. 配置 &lt;xx v-model=&#x27;xx&#x27; select=&#x27;xx&#x27;&gt;&lt;/xx&gt;","tags":[{"name":"Vue 基础知识 插件使用","slug":"Vue-基础知识-插件使用","permalink":"http://yoursite.com/tags/Vue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/"}],"categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"基础","slug":"Vue/基础","permalink":"http://yoursite.com/categories/Vue/%E5%9F%BA%E7%A1%80/"}]},{"title":"php基础","date":"2018-08-01T16:00:00.000Z","path":"wiki/PHP-基础/","text":"待更新","tags":[{"name":"php 基础","slug":"php-基础","permalink":"http://yoursite.com/tags/php-%E5%9F%BA%E7%A1%80/"}],"categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"},{"name":"基础","slug":"PHP/基础","permalink":"http://yoursite.com/categories/PHP/%E5%9F%BA%E7%A1%80/"}]},{"title":"vue中$route和$router的区别","date":"2018-08-01T16:00:00.000Z","path":"wiki/vue中-route和-router的区别/","text":"$route和$router的区别123$router为vueRouter的实例，相当于一个全局路由对象，里面含有很多属性和子对象 $route相当于当前正在跳转的路由对象","tags":[{"name":"Vue $route $router","slug":"Vue-route-router","permalink":"http://yoursite.com/tags/Vue-route-router/"}],"categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"基础","slug":"Vue/基础","permalink":"http://yoursite.com/categories/Vue/%E5%9F%BA%E7%A1%80/"}]},{"title":"vue-cli项目中src目录每个文件夹和文件的用法","date":"2018-06-24T16:00:00.000Z","path":"wiki/vue-cli项目中src目录每个文件夹和文件的用法/","text":"vue-cli项目中src目录每个文件夹和文件的用法？12345678910src assets | 静态资源 （图片、js、css）components | 非路由组件views | 路由组件router | 路由配置store | vuex（仓库）App.vue | 挂载的第一个组件main.js | 全局的文件index.html =&gt; main.js =&gt; App.vue","tags":[{"name":"Vue 基础知识 路由跳转","slug":"Vue-基础知识-路由跳转","permalink":"http://yoursite.com/tags/Vue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC/"}],"categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"基础","slug":"Vue/基础","permalink":"http://yoursite.com/categories/Vue/%E5%9F%BA%E7%A1%80/"}]},{"title":"v-if与v-show","date":"2018-06-19T16:00:00.000Z","path":"wiki/vue之v-if与v-show区别/","text":"v-if v-show区别1234567v-if更高的切换开销，v-show更高的渲染开销，频繁切换 v-show比较好，运行时条件不太可能改变 v-if比较好v-if监听组件的销毁与创建 v-if惰性，初始条件为假，什么也不做，只到条件第一次为真时候，才会开始条件渲染v-show 不管初始条件是什么，元素总是被渲染，并且只是简单的基于css进行切换","tags":[{"name":"Vue 基础知识 v-if v-show","slug":"Vue-基础知识-v-if-v-show","permalink":"http://yoursite.com/tags/Vue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-v-if-v-show/"}],"categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"基础","slug":"Vue/基础","permalink":"http://yoursite.com/categories/Vue/%E5%9F%BA%E7%A1%80/"}]},{"title":"vue中keep-alive的作用","date":"2018-04-19T16:00:00.000Z","path":"wiki/vue中keep-alive的作用/","text":"keep-alive1234567是什么？ 内置组件，能在组件切换过程中将状态保存在内存中，防止重复渲染dom说明：keep-alive不会再dom树中渲染","tags":[{"name":"Vue 基础知识 keep-alive","slug":"Vue-基础知识-keep-alive","permalink":"http://yoursite.com/tags/Vue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-keep-alive/"}],"categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"基础","slug":"Vue/基础","permalink":"http://yoursite.com/categories/Vue/%E5%9F%BA%E7%A1%80/"}]},{"title":"vue中watch和computed","date":"2018-04-19T16:00:00.000Z","path":"wiki/vue中watch和computed/","text":"watch和computed差异12345678computed ： 计算属性 1. 计算属性是由data中的已知值，得到一个新的值 2. 性能不好 3. 别人变化影响我自己 watch : 监听数据的变化 1. 监听data中的数据 2. 我的变化影响别人","tags":[{"name":"Vue 基础知识 watch computed","slug":"Vue-基础知识-watch-computed","permalink":"http://yoursite.com/tags/Vue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-watch-computed/"}],"categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"基础","slug":"Vue/基础","permalink":"http://yoursite.com/categories/Vue/%E5%9F%BA%E7%A1%80/"}]},{"title":"vue-cli3.0和vue-cli2.0项目构建、运行、编译命令区别","date":"2018-04-02T16:00:00.000Z","path":"wiki/vue-cli3.0和vue-cli2.0项目构建、运行、编译命令区别/","text":"一、安装上区别：1.Vue cli 2 版本安装命令 : 1npm install -g vue-cli 2.Vue cli 3 版本安装命令： 1npm install -g @vue/cli 二、创建项目区别1.Vue cli 2 版本创建项目命令 : 1vue init webpack project 2.Vue cli 3 版本创建项目命令 : 1vue create project 三. 编译运行项目区别1.Vue cli 2 版本编译运行项目命令 : 1npm run dev 2.Vue cli 3 版本编译运行项目命令 : 1npm run serve 项目目录结构可以明显的看出来，vue-cli2.0与3.0在目录结构方面，有明显的不同（vue3.0我是安装了css预处理器，所以看上去内容更丰富哈） vue-cli3.0移除了配置文件目录，config 和 build 文件夹 同时移除了 static 静态文件夹，新增了 public 文件夹，细心的你，打开层级目录还会发现， index.html 移动到 public 中 配置项vue-cli2.0的域名配置，分为开发环境和生产环境，所以配置域名时，需要在config中的dev.env.js和prod.env.js中分别配置 前面说过，到了3.0 config文件已经被移除，但是多了.env.production和env.development文件，除了文件位置，实际配置起来和2.0没什么不同 当然，没了config文件，跨域需要配置域名时，从config/index.js挪到了vue.config.js中，配置方法不变 在3.0中，vue.config.js中有关于mock的配置 要注意的是：mockjs是用来模拟产生一些虚拟的数据，方便前端在后端接口还没有开发出来时独立开发 即使使用了真实的url，但是mockjs拦截了ajax请求，返回的是设定好的本地数据 如果你想正常从后端获取数据，就要关掉mock的使用，我是直接删掉的，当然你可以选择别的办法 main.js中有一段关于mock.js的描述（注意上线前要去掉你的mock） 可视化界面找到项目，vue ui 命令会直接打开可视化界面，里面可以进行配置、依赖等操作 对于不喜欢命令行的皮友可以说是非常友好了","tags":[{"name":"Vue 基础  脚手架 基础","slug":"Vue-基础-脚手架-基础","permalink":"http://yoursite.com/tags/Vue-%E5%9F%BA%E7%A1%80-%E8%84%9A%E6%89%8B%E6%9E%B6-%E5%9F%BA%E7%A1%80/"}],"categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"基础","slug":"Vue/基础","permalink":"http://yoursite.com/categories/Vue/%E5%9F%BA%E7%A1%80/"}]},{"title":"本地存储使用场景","date":"2018-04-01T16:00:00.000Z","path":"wiki/Es6-本地存储使用场景/","text":"本地存储使用场景第一： 做移动端webapp项目时候, token存储在vuex后, 再次存入到本地存储, 防止刷新消失 第二: 聊天记录, 历史记录显示,利用本地存储, 退出页面后,聊天记录还可以正常显示.","tags":[{"name":"Es6  本地存储 使用场景","slug":"Es6-本地存储-使用场景","permalink":"http://yoursite.com/tags/Es6-%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"}],"categories":[{"name":"Es6","slug":"Es6","permalink":"http://yoursite.com/categories/Es6/"},{"name":"基础","slug":"Es6/基础","permalink":"http://yoursite.com/categories/Es6/%E5%9F%BA%E7%A1%80/"}]},{"title":"Promise","date":"2018-03-28T16:00:00.000Z","path":"wiki/Es6-Promise/","text":"PromisePromise 对象的状态和值一个Promise对象可能处于如下三种状态，PromiseStatus: pending | resolved | rejected下面分别介绍这三种状态。 pendingpending,”行将发生的”。相当于是一个初始状态。创建Promise对象时，且没有调用ok或者是err方法，相当于是初始状态。这个初始状态会随着你调用ok，或者是error函数而切换到另一种状态。 12var p = new Promise((ok,err)=&gt;&#123; console.info(&#x27;发呆.....&#x27; )&#125;)console.dir(p) resolved创建Promise对象时，在实参函数中调用了ok方法。 12var p = new Promise((ok,err)=&gt;&#123; console.info(&#x27;发呆.....&#x27; ); ok();&#125;)console.dir(p) 注意，上面的ok和err只是一个形参名字而已，我们在实参函数中主动调用了第一个形参。 rejected创建Promise对象时，调用error方法。 12var p = new Promise((ok,err)=&gt;&#123; console.info(&#x27;发呆.....&#x27; ); err()&#125;)console.dir(p) 三种状态的理解 状态是可转化 最初创建promise对象时，默认状态是pending，如果在函数体内部调用了第一个参数对应的函数，则状态变成了resolved；如果调用了第二个参数对应的函数，则状态变成了rejected。 12pending -----ok() --&gt; resolved;pending -----error()---&gt; rejected ; 上面使用的ok,error其实只是形参名字而已，在更多的场合下，我们会用resolve和reject来表示。如下： 1var p = new Promise( (resolve,reject) =&gt; &#123; &#125; ) 状态转换是不可逆的。一旦从pending —&gt; resolved（或者是rejected），就不可能再回到pending。也不能由resolved变成rejected，或者反过来。 promise的值promisevalue一个promise对象除了状态之外，还有promsievalue，在构造器中，这个值在调用resolve和reject方法时，自动传入。 例如： 12345var p = new Promise( (resolve,reject) =&gt; &#123; resolve(123); &#125; );// 此时，prommise对象p的状态是 resolved，值是123。var p = new Promise( (resolve,reject) =&gt; &#123; reject(1); &#125; );// 此时，prommise对象p的状态是 rejected，值是1。 单独来看promiseValue似乎没有什么意义，它的使用场景在于结合promise对象的实例方法一起来用来。 Promise实例的方法在js中，对象会从它的构造器的原型对象中继承方法。例如： 12var arr &#x3D; new Array();arr.push(); 上面的push方法其实是Array.protoType中的属性。 1arr.push &#x3D;&#x3D;&#x3D; Array.protoType.push ; &#x2F;&#x2F; true 同样的道理，一个promise对象也会从Promise.prototype中得方法。 then() catch() finally() then()方法then方法的作用是为Promise对象添加状态改变时的回调函数。 参数 返回值 格式它可以写两个参数，如下： 1promise对象.then(函数1，函数2) 它的第二个参数是可选的，即可以只写一个参数。 1promise对象.then(函数1) 它的两个参数都是函数。第一个参数是Resolved状态的回调函数，第二个参数是Reject状态的回调函数。 调用逻辑它的两个参数都是函数。它们的执行逻辑是: 如果promise对象的状态是resolved，则promisec对象.then()会自动调用第一个函数; 如果promise对象的状态是rejected，则promisec对象.then()会自动调用第二个函数，如果此时then方法并没有设置第二个参数，就会报错; 这种情况的处理方法在后面介绍 12345678910var p = new Promise((resolve,reject)=&gt;&#123; resolve();&#125;)p.then(()=&gt;&#123;console.info(&quot;then,成功&quot;)&#125;, ()=&gt;&#123;console.info(&quot;then,失败&quot;)&#125;)//--------------------------------------------------------------------------------------var p = new Promise((resolve,reject)=&gt;&#123; reject();&#125;)p.then(()=&gt;&#123;console.info(&quot;then,成功&quot;)&#125;, ()=&gt;&#123;console.info(&quot;then,失败&quot;)&#125;) 实参的值then的参数是两个回调函数，分别在p对象是resolve和reject自动调用。在调用它们时，会自动把promise对象的promisevalue当作实参给它们传递进去。 示例代码1 123456789var p = new Promise((resolve,reject)=&gt;&#123; resolve(1)//主动调用resolve，并传入&#125;)// 此时，P的状态是resolved，且值promiseValue 是1.p.then((res)=&gt;&#123;// 因为p的状态是resolved，所以自动执行then的第一个参数，并且把promisevalue传进来。 console.log(&quot;then,ok&quot;,res)&#125;) 示例代码2 123456789101112var p = new Promise((resolve,reject)=&gt;&#123; reject(2)//主动调用reject，并传入实参&#125;)// 此时，P的状态是rejected，且值promiseValue 是2.p.then((res)=&gt;&#123; // 因为p的状态是resolved，所以这句代码不会执行。 console.log(&quot;then,ok&quot;,res)&#125;,(err)=&gt;&#123; // 因为p的状态是rejected，所以自动执行then的第二个参数，并且把promisevalue传进来。 console.log(&quot;then,err&quot;,err)&#125;) 返回值then()方法的返回值也是一个promise对象，但是，它的返回值是一个新的promise对象（与调用then方法的并不是同一个对象），所以它支持链式写法。 即; 1234var p1 = new Promise(()=&gt;&#123;&#125;);var p2 = p1.then(); // p2也是一个promise对象。console.log(p1 === p2); // false 12345678910111213var p1 = new Promise( (resolve,reject) =&gt; &#123; // 做一些事情， // 根据情况，去执行resolved或者是rejected。 reject()&#125;)f_ok = function()&#123; console.info(&quot;当前的promise 的状态是ok的 &quot;)&#125;f_err = function()&#123; console.info(&quot;当前的promise的状态是error的&quot;)&#125;var p2 = p1.then(f_ok,f_err)console.info(p2 instance of Promise); // trueconsole.info(p1 === p2); // falseconsole.info(&quot;p1&quot;,p1)console.info(&quot;p2&quot;,p2) 如上代码可以说明p1.then()的结果是一个与p1不同的promise对象。换句话说，then()会封装一个全新的promise对象p2。 那既然 p2也是一个promise对象，那么，p2的状态（promiseStatus）和值(promiseValue)分别是什么？ p2的状态及promiseValue按如下规则来确定 如果p1的状态是pending,则p2的状态也是pending。 如果p1的状态是resolved，then()会去执行f_ok，则p2的状态由f_ok的返回值决定。 如果f_ok返回值不是promise对象，则p2的状态是resolved，且p2的promiseValue就是f_ok函数的return值。 如果f_ok返回值是一个promise对象，则p2的状态及promiseValue以这个promise对象为准。 如果p1的状态是rejected，then()会去执行f_err，则p2的状态由f_err的返回值决定。 如果f_err返回值不是promise对象，则p2的状态是resolved，且p2的promiseValue就是f_err函数的return值。 如果f_err返回值是一个promise对象，则p2的状态及promiseValue以这个promise对象为准。 catch()方法Promise.prototype.catch是.then(null, reject)的别名，用于指定发生错误时的回调函数 。比较经典的用法是这样： 1234567891011121314151617new Promise((resolve,reject)&#123;&#125;).then(function(result)&#123; // 如果promise对象的状态是resolved的，就会到这里来，并且result会接收promiseValue的值&#125;).catch(function(err)&#123; // 如果promise对象的状态是rejected的，就会到这里来，并且err会接收promiseValue的值&#125;)/// 上面的代码如何拆分来写的话，等价于：var p1 = new Promise((resolve,reject)&#123;&#125;);var p2 = p1.then(function(result)&#123;&#125;);var p3 = p2.catch(function(err)&#123;&#125;) fillay()方法无论状态如何，都会执行 下面我们来看一下promise.finally(f);，（1）f是一个无参函数，不论该promise最终是fulfilled还是rejected。（2）finally不改变promise的状态。 使用promise改造回调函数1234567891011121314把一个异步的带回调函数的功能改写成promise。1. 新建一个空模板function fnname(XXXXX)&#123; var p = new Promise((resolve,reject)=&gt;&#123; // 这里写具体的代码，并在某个恰当的时机去调用resolve和reject函数。 &#125;) return p;&#125;2.把功能代码放入new Promise的构造器中,根据实际情况调用resolve,reject，并给实参3.通过`fnname().then().catch()` 结构来使用。 基本代码 12345678910const fs = require(&#x27;fs&#x27;);fs.readFile(&quot;1.txt&quot;, &#x27;utf8&#x27;, (err, data) =&gt; &#123; if (err) &#123; reject(err); &#125; else &#123; resolve(data); &#125;&#125;); 封装方法 123456789101112131415161718192021const fs = require(&#x27;fs&#x27;);function readFile(filename) &#123; var p = new Promise((resolve, reject) =&gt; &#123; fs.readFile(filename, &#x27;utf8&#x27;, (err, data) =&gt; &#123; if (err) &#123; reject(err); &#125; else &#123; resolve(data); &#125; &#125;); &#125;); return p;&#125;readFile(&#x27;./server.js1&#x27;) .then(rs =&gt; &#123; console.log(rs); &#125;) .catch(err =&gt; &#123; console.log(&#x27;err&#x27;, err); &#125;); 面试题 写代码，完成如下功能： 123456789101112131415161718function sleep(time)&#123; // 请写出你的代码 var p = new Promise(function(resolve,reject)&#123; console.log(3); // 异步操作，根据执行结果，决定是否调用 resolve,reject setTimeout(function()&#123; resolve() &#125;, time) &#125;); return p;&#125;console.log(1);sleep(2000).then(()=&gt;&#123; console.log(&quot;4.其它工作&quot;)&#125;)console.log(2); sleep 的功用与settimeout一样：就是等2000毫秒之后再执行。","tags":[{"name":"Es6 基础  Promise","slug":"Es6-基础-Promise","permalink":"http://yoursite.com/tags/Es6-%E5%9F%BA%E7%A1%80-Promise/"}],"categories":[{"name":"Es6","slug":"Es6","permalink":"http://yoursite.com/categories/Es6/"},{"name":"基础","slug":"Es6/基础","permalink":"http://yoursite.com/categories/Es6/%E5%9F%BA%E7%A1%80/"}]},{"title":"JavaScript-this","date":"2018-03-24T16:00:00.000Z","path":"wiki/JavaScript-this/","text":"this常见问题概念问题12345678910111213141516171819执行上下文是执行的环境this叫做执行主体，是谁把他执行,所以他们两个不一回事。如何区分执行主体:和函数在那里执行和创建没有必然的关系一般我们提到this, 都是函数中的this, 不然全局中输出this === window我们所说的this是指函数中的this, 那我们如何区分执行主体,和函数在哪里执行创建没有必然的关系首先我们看函数前面是否有点,有点,他前面是谁this就是谁,没有点，this就是 window(非严格模式)/undefined(严格模式)--- 自执行函数this 一般是指window或者undefined--- 回调函数this一般也是thih或者undeifend(除非某个函数内部给回调函数做了特殊处理，这样函数中的this有自己的特殊处理)--- 给当前元素的某个事件行为绑定方法, 当事件触发,方法中的this就是当前操作的元素,（特殊 ie 678基于dom2时间绑定attachevent 方法中的this不是元素）箭头函数中（私有块级上下文）没有自己的this,所用到的this 都是期上下级上下文中的this（也就是说没有初始化this这一步） 什么时间能确定this12this的指向在函数定义的时候是确定不了的，只有当函数执行的时候，才知道this到底指向谁，实际上this最终的指向是那个调用它的对象。 普通函数中的This1234567891011121314151617181920this最终指向的是调用它的对象function fn()&#123; var user = &quot;hunt_bo&quot;; console.log(this.user); //undefined console.log(this); //Window&#125;fn();这时候的this指向全局对象window。下面的代码就可以证明。和上边是一样的效果，区别就是我们定义的一些变量函数，其实是在给window添加属性。function fn()&#123; var user = &quot;hunt_bo&quot;; console.log(this.user); //undefined console.log(this); //Window&#125;window.fn(); 构造函数中的This12345678910function Person(age, name) &#123; this.age = age; this.name = name console.log(this) // 此处this分别指向Person的实例对象p1和p2&#125;var p1 = new Person(15, &#x27;张三&#x27;)var p2 = new Person(18, &#x27;李四&#x27;)在构造函数中，它的this始终指向构造函数构造出来的实例，结合前面所分享的原型里边的知识，在构造函数中直接打印this.__proto__.constructor，就会直接打印构造函数自己，有兴趣的话可以试一下。 对象方法中的This12345678var obj = &#123; fn: function () &#123; console.log(this); // obj &#125;&#125;obj.fn();对象方法调用的时候， 此时this指向该方法所属的对象，就是说fn是obj的一个方法，那么当通过obj.fn调用的时候，方法中的this指向的是obj对象。 事件绑定中的This12345678910&lt;body&gt; &lt;button id=&quot;btn&quot;&gt;text&lt;/button&gt;&lt;script&gt; var oBtn = document.getElementById(&quot;btn&quot;); oBtn.onclick = function() &#123; console.log(this); &#125;&lt;/script&gt;&lt;/body&gt;在事件绑定中的this，指向的是绑定事件的对象，就是说this指向button 定时器中的this123456setInterval( function()&#123; console.log(this); //window &#125;, 3000);定时器中的this指向的是window，这个就不做过多的解释了。 箭头函数中的this123箭头函数中的this指向的是定义时的this，而不是执行时的this，说白了就是箭头函数是没有this，this指向谁主要取决于箭头函数所处的环境，箭头函数中的this指向外部环境中的this指向。虽然有些拗口，但是应该还是很好理解的。 改变this的指向1234567改变this的指向的方法主要有call，apply，bind.call(), call(thisScope, arg1, arg2, arg3...) .apply(), apply(thisScope, [arg1, arg2, arg3...]);两个参数 .bind() bind(thisScope, arg1, arg2, arg3...) 小技巧12看有没有点, 有点的谁调用属于谁, 没有点就是window的执行主体是谁 跟在哪里调用的没有关系,要看谁谁调用的。","tags":[{"name":"JavaScript 基础知识 this","slug":"JavaScript-基础知识-this","permalink":"http://yoursite.com/tags/JavaScript-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-this/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"基础","slug":"JavaScript/基础","permalink":"http://yoursite.com/categories/JavaScript/%E5%9F%BA%E7%A1%80/"}]},{"title":"回调地狱","date":"2018-03-19T16:00:00.000Z","path":"wiki/Es6-回调地狱/","text":"回调地狱回调地狱其实就是异步回调里面嵌套异步回调,此次请求的参数是上次请求的结果,多个类似这样的嵌套. 解决办法：await asyncawait 后面跟的是promise, 他会强制把异步函数变成同步, 后面的promise结果可以在前面用一个变量接收, 但是会造成代码阻塞,需要谨慎使用。 为了避免代码阻塞, 需要在外部父级函数加一个async, await和async配合使用 await 后面的promise只有resolve了之后才会执行后面的代码逻辑如果要捕获reject,要在await函数外面包一层 try/catch async函数es2017 引入async函数，让异步操作更加方便：写法上更接近同步。 async 它用来修饰一个函数，会返回一个promise对象，可以使用then方法添加回调函数。当函数执行时，如果遇到 了await就会先返回，等 到异步操作完成，再接着执行函数体后面的语句。 1234567function f1()&#123; return 1;&#125;async function f2() &#123; return 2;&#125; await 接一个promise对象， 它会自动解析这个promise对象中的promiseValue。 只能出现在async函数中。 一般在后面接一个函数，而这个函数会返回一个promise对象 如下示例： 12345678910111213141516const fs = require(&#x27;fs&#x27;);function readFile(filename) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(filename, &#x27;utf8&#x27;, (err, data) =&gt; &#123; if (err) &#123; resolve(null); &#125; else &#123; resolve(data); &#125; &#125;); &#125;);&#125;async function dosomethin()&#123; let rs = await readFile(); //允许promise的返回值存入变量, 异步变为同步,使代码更优雅&#125;","tags":[{"name":"Es6 基础  Promise 回调地狱 await async","slug":"Es6-基础-Promise-回调地狱-await-async","permalink":"http://yoursite.com/tags/Es6-%E5%9F%BA%E7%A1%80-Promise-%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1-await-async/"}],"categories":[{"name":"Es6","slug":"Es6","permalink":"http://yoursite.com/categories/Es6/"},{"name":"基础","slug":"Es6/基础","permalink":"http://yoursite.com/categories/Es6/%E5%9F%BA%E7%A1%80/"}]},{"title":"Laravel常用命令","date":"2018-03-17T16:00:00.000Z","path":"wiki/PHP-Laravel常用命令/","text":"Laravel 框架高频使用命令1234567891011php artisan key:generate 生成 App Keyphp artisan make:controller 生成控制器php artisan make:model 生成模型php artisan make:policy 生成授权策略php artisan make:seeder 生成 Seeder 文件php artisan migrate 执行迁移php artisan migrate:rollback 回滚迁移php artisan migrate:refresh 重置数据库php artisan db:seed 填充数据库php artisan tinker 进入 tinker 环境php artisan route:list 查看路由列表","tags":[{"name":"PHP Laravel 命令","slug":"PHP-Laravel-命令","permalink":"http://yoursite.com/tags/PHP-Laravel-%E5%91%BD%E4%BB%A4/"}],"categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"},{"name":"框架","slug":"PHP/框架","permalink":"http://yoursite.com/categories/PHP/%E6%A1%86%E6%9E%B6/"},{"name":"Laravel","slug":"PHP/框架/Laravel","permalink":"http://yoursite.com/categories/PHP/%E6%A1%86%E6%9E%B6/Laravel/"}]},{"title":"vue-loader干什么用的","date":"2018-02-17T16:00:00.000Z","path":"wiki/vue-loader干什么用的/","text":"vue-loader干什么用的123项目打包 npm run build ---&gt; index.html 开发的时候操作的都是 xxx.vue文件 loader ： 加载器 用途 : js可以写es6、style样式可以scss或less、template可以加jade等","tags":[{"name":"Vue 基础知识 vue-loader","slug":"Vue-基础知识-vue-loader","permalink":"http://yoursite.com/tags/Vue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-vue-loader/"}],"categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"基础","slug":"Vue/基础","permalink":"http://yoursite.com/categories/Vue/%E5%9F%BA%E7%A1%80/"}]},{"title":"怎么使用？vue跨域请求接口代理方式","date":"2017-08-01T16:00:00.000Z","path":"wiki/vue跨域请求接口代理方式怎么使用？/","text":"axios是什么？怎么使用？vue跨域请求接口代理方式？1234567891011121314151. axios是什么？怎么使用 a&gt; 下载 npm install axios --save b&gt; 引入(main.js) import axios from &#x27;axios&#x27;; Vue.prototype.axios = axios; c&gt; 请求方式，以及传递参数 axios.get(&#x27;/api/login?userName=???&amp;userPwd=???&#x27;) axios.post(&#x27;/api/login&#x27;,&#123; userName:??, userPwd:??? &#125;) 2. 设置代理，请求接口（跨域） config/index.js proxyTable: &#123; &#x27;/api&#x27;:&#123; target:&quot;http://localhost:8080/&quot;, changeOrigin:true, pathRewrite:&#123; &#x27;^/api&#x27;:&#x27;static/mock&#x27; &#125; &#125; &#125; 修改了webpack的配置，一定要重启一下服务","tags":[{"name":"Vue 跨域 接口代理","slug":"Vue-跨域-接口代理","permalink":"http://yoursite.com/tags/Vue-%E8%B7%A8%E5%9F%9F-%E6%8E%A5%E5%8F%A3%E4%BB%A3%E7%90%86/"}],"categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"基础","slug":"Vue/基础","permalink":"http://yoursite.com/categories/Vue/%E5%9F%BA%E7%A1%80/"}]},{"title":"vue路由的跳转方式","date":"2017-05-18T16:00:00.000Z","path":"wiki/vue路由的跳转方式/","text":"路由的跳转方式121. router-link 2. this.$router.xxx push() ： history添加一个记录 replave() ： history不会记录上 go() &#x3D;&#x3D;&gt;正整数 或者 负数","tags":[{"name":"Vue 基础知识 路由跳转","slug":"Vue-基础知识-路由跳转","permalink":"http://yoursite.com/tags/Vue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC/"}],"categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"基础","slug":"Vue/基础","permalink":"http://yoursite.com/categories/Vue/%E5%9F%BA%E7%A1%80/"}]},{"title":"vuex的使用","date":"2017-05-14T16:00:00.000Z","path":"wiki/vuex的使用/","text":"vuex原理123456789101. vuex其实是一个vue的插件，高度依赖vue.js 2. vue插件都需要一个install方法， install方法调用了applyMixin，该方法主要是在所有组件中的beforeCreate中注入了this.$store对象。 3. vue 自身的响应式设计，依赖监听、依赖收集都属于 vue 对象 Property set get 方法的代理劫持。 常用方法State、 Getter、Mutation 、Action、 Module VueX 的使用1234567创建容器实例并且导出--&gt;在main.js导入组件中this.$store 其实就是我们导出的store实例，原因是 Vuex自动帮我们把容器实例挂载到了Vue.prototype原型对象 中了，所以我们在哪里都可以用 state(容器的状态)12345678state-&gt;类似于组件中的data，简单理解就是需要把共享的数据初始化到state中state-&gt;访问-&gt;this.$store.state.xxx 模板中$store.state.xxx****************************************************************************************************************** mutation(只能同步，直接更改状态)12345678910111213141516171819202122mutations(修改容器的方法)mutations 类似于methods 主要用来修改state mutations中没有thismutations 函数的第一个参数是state mutations: &#123; setUser (state, data) &#123; state.user = data &#125; 调用-&gt;this.$store.commit(&#x27;mutation函数名&#x27;, 可选参数)注意： 修改state只能通过修改mutations，不能直接修改state数据 调试工具只记录mutations的提交 mutations 传参 传过个 可以传对象过去 不能再muations中执行异步操作，修改state，调试工具出问题 ****************************************************************************************************************** Action –&gt;作用 定义 调用12345678910111213141516action 类似于mutation 不同的是把异步操作写到action也不要 在action中修改state，action 中异步操作结束以后，提交 mutation 来修改 stateaction 函数的第 1 个参数是容器对象action 也可以像 mutation 函数一样自定义传参使用视图=&gt;@click=&quot;$store.dispatch(&#x27;action函数名&#x27;，可选参数)&quot;action里面函数第一个参数默认接受store实例，用store.commit提交在mutation里面，函数第一个参数默认state****************************************************************************************************************** 异步在试图上做分发($store.dispatch)，在action里面commit 提交mutation (store.commit)，在mutation里面修改state","tags":[{"name":"Vue 基础知识 VueX","slug":"Vue-基础知识-VueX","permalink":"http://yoursite.com/tags/Vue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-VueX/"}],"categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"基础","slug":"Vue/基础","permalink":"http://yoursite.com/categories/Vue/%E5%9F%BA%E7%A1%80/"}]},{"title":"vue组件传值","date":"2017-05-14T16:00:00.000Z","path":"wiki/vue组件传值/","text":"组件传值123父传子 props字传父 $emit传递一个事件，父组件监听事件兄弟传值 bus传值 $emit触发 $on监听","tags":[{"name":"Vue 基础知识 组件传值","slug":"Vue-基础知识-组件传值","permalink":"http://yoursite.com/tags/Vue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"}],"categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"基础","slug":"Vue/基础","permalink":"http://yoursite.com/categories/Vue/%E5%9F%BA%E7%A1%80/"}]},{"title":"vue中的data为什么必须是一个函数","date":"2016-09-27T16:00:00.000Z","path":"wiki/vue中的data为什么必须是一个函数/","text":"Vue 中的data为什么必须是一个函数12345678Vue 组件 data 为什么必须是函数 不用脚手架 vue.js new Vue(&#123; el:&quot;#app&quot;, template:xxx data: &#123; &#125; &#125;) 脚手架 组件 data 为什么必须是函数? 因为 JS 本身的特性带来的， 如果 data 是一个对象，那么由于对象本身属于引用类型， 当我们修改其中的一个属性时， 会影响到所有 Vue 实例的数据。如果将 data 作为一个函数返回一个对象， 那么每一个实例的 data 属性都是独立的，不会相互影响了。","tags":[{"name":"Vue 基础知识 date","slug":"Vue-基础知识-date","permalink":"http://yoursite.com/tags/Vue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-date/"}],"categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"基础","slug":"Vue/基础","permalink":"http://yoursite.com/categories/Vue/%E5%9F%BA%E7%A1%80/"}]},{"title":"Vue生命周期","date":"2015-08-14T16:00:00.000Z","path":"wiki/vue生命周期/","text":"关于Vue生命周期1234(2+) beforeCreate created beforeMount mounted beforeUpdate updated beforeDestroy destroyed *****使用了 keep-alive 就会多2个生命周期： activated deactivated**** 生命周期总结1234567891011121314beforeCreate ：vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。 created ： vue实例的数据对象data有了，但是$el还是没有 载入前/后 beforeMount : vue实例的$el和data都初始化了,但还是挂载之前为虚拟dom节点，data.msg还未替换。 mounted : vue实例挂载完成,data.msg成功渲染更新前/后 当data变化时，会触发：beforeUpdate、updated 销毁前/后 当销毁的时候，会触发： beforeDestroy、destroyed -----&gt;DOM 渲染在哪个周期中就已经完成 ： mounted 文档解读1234567891011121314生命周期函数,就是vue在某一个时间点会自动执行的函数beforemount------&gt;&gt;模板和数据相结合，即将挂载到页面之前的一瞬间(页面还没有被渲染)mounted------&gt;&gt;beforemount执行之后，模板结合数据生成的dom元素会被挂载到页面上,也就是hello显示到页面之上,此时页面挂载后，会调用mounted， 页面已经被渲染完毕了.before update------&gt;&gt;当数据发生改变,还没有重新渲染之前，会调用 before updateupdated------&gt;&gt;数据改变之后,会调用 updated组件即将销毁 beforedestroy组件实例被销毁之后，destroied","tags":[{"name":"Vue 基础知识 生命周期","slug":"Vue-基础知识-生命周期","permalink":"http://yoursite.com/tags/Vue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"}],"categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"基础","slug":"Vue/基础","permalink":"http://yoursite.com/categories/Vue/%E5%9F%BA%E7%A1%80/"}]},{"title":"CSS案例","date":"2015-05-10T16:00:00.000Z","path":"wiki/CSS-小案例/","text":"导航条中间加 ‘|’123456789101112131415161718192021222324252627282930313233343536373839&lt;style&gt; * &#123; margin: 0px; list-style: none; &#125; .nav &#123; width: 100%; overflow: hidden; padding-top: 20px; /* 水平垂直居中 */ /* position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); */ &#125; ul &#123; padding-left: 180px; &#125; ul li &#123; float: left; &#125; li+li::before &#123; margin: 0px 10px; content: &#x27;|&#x27;; &#125; &lt;/style&gt; &lt;div class=&quot;nav&quot;&gt; &lt;ul&gt; &lt;li&gt;小米商城&lt;/li&gt; &lt;li&gt;华为商城&lt;/li&gt; &lt;li&gt;锤子&lt;/li&gt; &lt;li&gt;vivo&lt;/li&gt; &lt;li&gt;oppo&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;","tags":[{"name":"CSS基础 CSS案例","slug":"CSS基础-CSS案例","permalink":"http://yoursite.com/tags/CSS%E5%9F%BA%E7%A1%80-CSS%E6%A1%88%E4%BE%8B/"}],"categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"},{"name":"基础","slug":"CSS/基础","permalink":"http://yoursite.com/categories/CSS/%E5%9F%BA%E7%A1%80/"}]},{"title":"CSS行高设置","date":"2015-04-08T16:00:00.000Z","path":"wiki/CSS-行高/","text":"行内元素没有行高html 行内元素是没有宽高的！也就是说没有width！高的话可以用line-height撑起来。 要想行内元素有宽高，可以将行内元素转化为块级元素或者行内块元素 用block或者inline-block 块或者行内块元素，一个独占一行，一个不独占一行,调行高， line-height padding-top 是要算在高度里面的导致边长，margin-top能改变高度，但是还会导致整体移动。vertical-align可以调整行内块的属性或者具体的值。基线对齐 主要用于行内块元素 设置float浮动会隐式修改元素的display为block 设置宽高","tags":[{"name":"CSS基础 行高","slug":"CSS基础-行高","permalink":"http://yoursite.com/tags/CSS%E5%9F%BA%E7%A1%80-%E8%A1%8C%E9%AB%98/"}],"categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"},{"name":"基础","slug":"CSS/基础","permalink":"http://yoursite.com/categories/CSS/%E5%9F%BA%E7%A1%80/"}]},{"title":"CSS基础","date":"2015-04-01T16:00:00.000Z","path":"wiki/CSS--基础/","text":"1234567891011121314css选择器总结:基本选择器: 就是我们说的标签 属性选择器: [] 不限于class idid选择器: #id类选择器: .交集选择器: 两个选择器构成，其中第一个为标签选择器，第二个为class选择器 p.class名并集选择器: 各种选择器组合 逗号隔开 多个选择器应用同一样式后代选择器: 上下文选择 层次间隔无限 选取后面所有子代选择器: &gt; 标识, 只会选择子元素, 不包含孙子元素等相邻兄弟选择器: +号标识 必须兄弟相邻元素 排除第一个 循环查找兄弟选择器: ~号标识 必须兄弟元素 排除第一个 循环查找 CSS 行内元素和块元素H1-H5 标题，ul li,ol li,table,form,dl, div, from, menu, p,prea, span, img, input,i,strike,strong,sub,textareaCSS 有哪些引入方式行内式内联式外链式导入式内联式外链式导入的区别1234567891011121314151617加载顺序 link引入的css在加载页面时同时加载，而@import中的css要在页面加载完毕后加载从属关系 link是HTML提供的标签 @import是css的语法规则，只能加载在style标签内和css文件中兼容性 @import是css2.1时提出的，只能用于IE5+，而link不受兼容影响 DOM可控性link支持js控制DOM改变样式，而@import不支持 @import 的用法 @import必须写在样式顶部，即import规则一定要先于除了@charset的其他任何CSS规则 ———MDN引入位置 在html中 &lt;style&gt;@import url(引入的css路径);/*这个必须要写在style的第一行*/&lt;/style&gt; 在css中 @import url(引入的css路径); @import &quot;引入的css路径&quot;; /*这个@import必须要写在CSS的第一行*/不推荐使用@import 影响浏览器的并行下载 多个@import的使用会使浏览器下载顺序紊乱 3.CSS 选择器有哪些基本选择器1234567891011121314151617181920最常见的 CSS 选择器是元素选择器。换句话说，文档的元素就是最基本的选择器。 如果设置 HTML 的样式，选择器通常将是某个 HTML 元素，比如 p、h1、em、a，甚至可以是 html 本身 html &#123; color: black;&#125;h1 &#123; color: blue;&#125;h2 &#123; color: silver;&#125; 属性选择器123456789101112131415161718192021可以为拥有指定属性的 HTML 元素设置样式，而不仅限于 class 和 id 属性。注释：只有在规定了 !DOCTYPE 时，IE7 和 IE8 才支持属性选择器。在 IE6及更低的版本中，不支持属性选择[attribute] 用于选取带有指定属性的元素。[attribute=value] 用于选取带有指定属性和值的元素。[attribute~=value] 用于选取属性值中包含指定词汇的元素。[attribute|=value] 用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。[attribute^=value] 匹配属性值以指定值开头的每个元素。[attribute$=value] 匹配属性值以指定值结尾的每个元素。[attribute*=value] 匹配属性值中包含指定值的每个元素。&lt;style &gt; [title]&#123; color:red; &#125;&lt;/style&gt;&lt;button title=&quot;登录&quot; &gt;登录&lt;/button&gt;&lt;button&gt;登录&lt;/button&gt; id 选择器12345标识 #号*#intro &#123;font-weight:bold;&#125;&lt;p id=&quot;intro&quot;&gt;This is a paragraph of introduction.&lt;/p&gt; 类选择器123456789101112131415161718192021222324252627282930313233343536在 CSS 中，类选择器以一个点号显示：&lt;h1 class=&quot;important&quot;&gt;This heading is very important.&lt;/h1&gt;&lt;p class=&quot;important&quot;&gt;This paragraph is very important.&lt;/p&gt;*.important &#123;color:red;&#125; 或者 .important &#123;color:red;&#125;类选择器可以结合元素选择器来使用,希望只有段落显示为红色文本p.important &#123;color:red;&#125;希望为 h1 元素指定不同的样式，可以使用选择器 h1.importantCSS 多类选择器&lt;p class=&quot;important warning&quot;&gt;This paragraph is a very important warning.&lt;/p&gt;.important &#123;font-weight:bold;&#125;.warning &#123;font-style:italic;&#125;.important.warning &#123;background:silver;&#125;如果一个多类选择器包含类名列表中没有的一个类名，匹配就会失败。请看下面的规则：.important.urgent &#123;background:silver;&#125; 匹配失败,这个选择器将只匹配 class属性中包含词 important 和 urgent 的 p 元素。因此，如果一个 p 元素的 class属性中只有词 important 和 warning，将不能匹配。不过，它能匹配以下元素：&lt;p class=&quot;important urgent warning&quot;&gt;This paragraph is a very important and urgent warning.&lt;/p&gt; 交集选择器123456789101112要点: 两个选择器构成，其中第一个为标签选择器，第二个为class选择器 p.class名/*交集选择器*//*既是P标签，类名称又会text的元素字体变为红色*/p.text&#123; color: red;&#125; /*交集选择器-多个选择器包含的元素*/&lt;p&gt;好好学习1&lt;/p&gt; &lt;p class=&quot;text&quot;&gt;好好学习2&lt;/p&gt; &lt;p class=&quot;text&quot;&gt;好好学习3&lt;/p&gt; &lt;p&gt;好好学习4&lt;/p&gt; 并集选择器12345678910111213141516171819202122232425262728CSS并集选择器也叫群选择器，是由多个选择器通过逗号连接在一起的，这些选择器分别是：标签选择器、类选择器或id选择器等。在声明各种CSS选择器时，如果某些选择器的风格完全相同，或者部分相同，便可以利用并集选择器同时声明这些风格相同的CSS选择器。并集选择器允许同时给多个选择器应用同一种样式,如h1,h2,p,.color,#one&#123; color:blue; font-size:14px;&#125;要点: 逗号隔开的多个(多种)选择器 应用同一种样式 /*并集选择器*//*让container下的所有元素内容为蓝色*/#container p,span,em,strong&#123; color: blue;&#125;/*并集选择器-多个选择 所有匹配的元素*/&lt;div id=&quot;container&quot;&gt; &lt;p&gt;好好学习1&lt;/p&gt; &lt;span&gt;好好学习2&lt;/span&gt;&lt;br&gt; &lt;em&gt;好好学习3&lt;/em&gt;&lt;br&gt; &lt;strong&gt;好好学习4&lt;/strong&gt;&lt;/div&gt; 后代选择器1234567891011121314有关后代选择器有一个易被忽视的方面，即两个元素之间的层次间隔可以是无限的根据上下文选择元素,一般定义不超过三级(便于阅读)要点： 上下文选择 层次间隔无限 选取后面所有h1 em &#123;color:red;&#125; h1.ts1 em &#123;color:red;&#125; &lt;h1 class=&#x27;ts1&#x27;&gt; &lt;em&gt;em1&lt;/em&gt; &lt;p&gt; &lt;em&gt;em2&lt;/em&gt; &lt;/p&gt; &lt;/h1&gt;em1 和 em2 都会被渲染 子代选择器123456789101112131415161718192021222324252627282930要点: &gt; 标识, 只会选择子元素, 不包含孙子元素等与后代选择器相比，子元素选择器只能选择作为某元素子元素的元素。 &lt;style&gt; h1 &gt; strong &#123; color: red; &#125; &lt;/style&gt;这个规则会把第一个 h1 下面的两个 strong 元素变为红色，但是第二个 h1 中的 strong 不受影响： &lt;h1&gt;This is &lt;strong&gt;very&lt;/strong&gt; &lt;strong&gt;very&lt;/strong&gt; important.&lt;/h1&gt; &lt;h1&gt; This is &lt;em&gt;really &lt;strong&gt;very&lt;/strong&gt;&lt;/em&gt; important. &lt;/h1&gt;或者&lt;h1&gt; &lt;strong&gt;h1.very1&lt;/strong&gt; &lt;strong&gt;h1.very2&lt;/strong&gt; &lt;p&gt; &lt;strong&gt;p.very&lt;/strong&gt; &lt;/p&gt; &lt;/h1&gt; 只会渲染 very1 very2 结合后代选择器和子选择器, 请看下面这个选择器： table.company td &gt; p 上面的选择器会选择作为 td 元素子元素的所有 p 元素，这个 td 元素本身从 table 元素继承， 该 table 元素有一个包含 company 的 class 属性。 兄弟、相邻兄弟选择器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152相邻兄弟选择器‘+’选择器则表示某元素后相邻的兄弟元素，也就是紧挨着的，是单个的。但是也会循环查找，即当两个兄弟元素相同时，会再一次循环查找关键字 +号标识 必须兄弟相邻元素 排除第一个 循环查找 例子一: p+p::before &#123; color:red; content: &#x27;123&#x27;; display:block; &#125; &lt;p&gt;p1&lt;/p&gt; &lt;p&gt;p2&lt;/p&gt; &lt;h1&gt;hello&lt;/h1&gt; &lt;p&gt;p4&lt;/p&gt; &lt;p&gt;p5&lt;/p&gt; &lt;p&gt;p6&lt;/p&gt; &lt;p&gt;p7&lt;/p&gt; &lt;p&gt;p8&lt;/p&gt; 此时只有p2 以及p5 p6 p7 p8 有作用, 从p4 开始把p4当做第一个元素重新查找 例子二: li+li::before &#123; margin: 0px 10px; content: &#x27;|&#x27;; &#125; 导航栏中间加一个竖杠兄弟选择器而‘~’选择器则表示某元素后所有同级的指定元素，强调所有的要点 ~号标识 必须兄弟元素 排除第一个 循环查找例子一: p ~ p::before &#123; color:red; content: &#x27;123&#x27;; display:block; &#125; &lt;p&gt;p1&lt;/p&gt; &lt;p&gt;p2&lt;/p&gt; &lt;h1&gt;hello&lt;/h1&gt; &lt;p&gt;p4&lt;/p&gt; &lt;p&gt;p5&lt;/p&gt; &lt;p&gt;p6&lt;/p&gt; &lt;p&gt;p7&lt;/p&gt; &lt;p&gt;p8&lt;/p&gt; 此时除了p1 其他都会出现红色123 伪类选择器123456789101112131415161718192021222324252627282930313233343536373839404142434445伪类可以与 CSS 类配合使用：a.red:visited &#123;color:#FF0000;&#125;&lt;a class=&quot;red&quot; href=&quot;css-syntax.html&quot;&gt;CSS 语法&lt;/a&gt;CSS伪类选择器：a:link 没有访问之前a标签的样式a:visited 已访问a标签的样式a:hover a标签鼠标移上的样式a:actived a标签鼠标按下的样式input:focus input表单元素获取焦点input:blur input表单元素失去焦点CSS3新增的伪类选择器：:checked 被选中 主要用在input表单元素上:not 排除:last-child 最后一个元素:nth-child(n) n表示具体的第几个 odd/2n+1 奇数 even/2n 偶数:only-child 仅仅/唯一的元素:nth-last-child(n) 倒数第几个元素 :nth-last-child(1) &lt;=&gt; :last-child:first-of-type 第一个同级兄弟元素:last-of-type 最后一个同级兄弟元素:only-of-type 只有一个同级兄弟元素:nth-of-type(n) 第几个同级兄弟元素:nth-last-of-type(n) 倒数第几个同级兄弟元素:empty 空内容 伪元素选择器123456789101112131415伪元素就是假象的元素，并不存在DOM树中，无法捕获，也无法绑定事件::after是CSS3中伪元素写法，区别于CSS2中:的伪类写法，:after是css2写法，::after是css3写法。用于向渲染的元素后添加内容，这些添加不会出现在DOM中，仅在css渲染层加入记住:只要碰到伪元素before after,content一定要加.只要宽度不起作用，就加display:block/inline-block 转换为块或者行内块:first-line:为某个元素的第一行文字使用样式；:first-letter:为某个元素中的文字的首字母或第一个字使用样式；:before:在某个元素之前插入一些内容；content不能省 没有设置为空:after: 在某个元素之后插入一些内容；content不能省 没有设置为空 派生选择器1234567891011121314151617181920212223242526272829303132要点： 上下文关系定义样式通过依据元素在其位置的上下文关系来定义样式，你可以使标记更加简洁。li strong &#123; font-style: italic; font-weight: normal; &#125;&lt;p&gt;&lt;strong&gt;我是粗体字，不是斜体字，因为我不在列表当中，所以这个规则对我不起作用&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;我是斜体字。这是因为 strong 元素位于 li 元素内。&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;我是正常的字体。&lt;/li&gt;&lt;/ol&gt;在上面的例子中，只有 li 元素中的 strong 元素的样式为斜体字，无需为 strong元素定义特别的 class 或 id，代码更加简洁。strong &#123; color: red; &#125;h2 &#123; color: red; &#125;h2 strong &#123; color: blue; &#125;&lt;p&gt;The strongly emphasized word in this paragraph is&lt;strong&gt;red&lt;/strong&gt;.&lt;/p&gt;&lt;h2&gt;This subhead is also red.&lt;/h2&gt;&lt;h2&gt;The strongly emphasized word in this subhead is&lt;strong&gt;blue&lt;/strong&gt;.&lt;/h2&gt;","tags":[{"name":"CSS基础 选择器","slug":"CSS基础-选择器","permalink":"http://yoursite.com/tags/CSS%E5%9F%BA%E7%A1%80-%E9%80%89%E6%8B%A9%E5%99%A8/"}],"categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"},{"name":"基础","slug":"CSS/基础","permalink":"http://yoursite.com/categories/CSS/%E5%9F%BA%E7%A1%80/"}]},{"title":"Vue插槽详解","date":"2015-03-25T16:00:00.000Z","path":"wiki/Vue插槽详解/","text":"匿名插槽(文档中的默认插槽)12345678910111213141516171819所谓插槽就是在子组件中定义一个slot标签,把父组件中的内容填充过去使用匿名插槽 会把父组件中子组件内的所有内容一次性传递过去如果有多个slot, 就想是把所有内容copy了好几份, 一个slot标签就是一份copy父组件&lt;div&gt;&lt;child&gt;jack lily &lt;&#x2F;child&gt;&lt;&#x2F;div&gt;子组件&lt;div&gt;你好 &lt;slot&gt;&lt;&#x2F;slot&gt;&lt;&#x2F;div&gt;此时会把jack lily会把slot标签替换掉, 插槽后备内容123456789101112父组件&lt;div&gt;&lt;child&gt;jack&lt;&#x2F;child&gt;&lt;&#x2F;div&gt;子组件&lt;div&gt;你好 &lt;slot&gt;tom&lt;&#x2F;slot&gt;&lt;&#x2F;div&gt;父组件中子组件内没有内容, 则子组件显示tom, 如果传入内容,tom不显示, 就会显示jack 带名字的插槽(具名插槽)12345678910111213141516171819202122匿名插槽有缺点,slot会把父组件里面的内容全部替换掉,不能针对性的替换，所以我们也要用具名插槽, slot根据name值接收相对应的内容，从而显示不同内容&lt;div&gt; &lt;child&gt; &lt;span name&#x3D;&#39;header&#39;&gt;&lt;&#x2F;span&gt; &lt;span name&#x3D;&#39;body&#39;&gt;&lt;&#x2F;span&gt; &lt;&#x2F;child&gt;&lt;&#x2F;div&gt;&lt;child&gt; &lt;span slot&#x3D;&#39;header&#39;&gt;默认header&lt;&#x2F;span&gt; &lt;span slot&#x3D;&#39;body&#39;&gt;默认body&lt;&#x2F;span&gt;&lt;&#x2F;child&gt;带名字的插槽 针对性 传入接收具名插槽也支持后备, 如传入显示默认内容 作用域插槽123456789101112让插槽内容能够访问子组件中才有的数据自 2.6.0 起 slot-scope被废弃通过属性绑定的方式, 把数据绑定到slot上,然后在父级作用域通多slot-scope 得到一个对象, 是在slot上绑定的属性集合,然后拿到我们需要的值, 然后再通过 具名插槽, 把整个内容传给插槽,做一个回传,有一个一来一回的过程3.0版本还是 首先绑定属性, 我们叫做插槽 prop父级作用域使用v-solt 获取我们需要的值, 其他同上","tags":[{"name":"Vue  基础知识 slot插槽","slug":"Vue-基础知识-slot插槽","permalink":"http://yoursite.com/tags/Vue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-slot%E6%8F%92%E6%A7%BD/"}],"categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"基础","slug":"Vue/基础","permalink":"http://yoursite.com/categories/Vue/%E5%9F%BA%E7%A1%80/"}]},{"title":"git常用命令","date":"2015-03-25T16:00:00.000Z","path":"wiki/工具-git常用命令/","text":"git 常用的命令总结了一下, 不用再每次都去百度了 分支常用命令 12345678910查看分支：git branch git branch -a 查看远程分支创建分支：git branch &lt;name&gt;切换分支：git checkout &lt;name&gt;或者git switch &lt;name&gt;创建+切换分支：git checkout -b &lt;name&gt;或者git switch -c &lt;name&gt;合并某分支到当前分支：git merge &lt;name&gt;删除分支：git branch -d &lt;name&gt; 先切换到别的分支git log 退出 q 推拉代码常用命令 123456789101112131415拉取远程dev git pull origin dev 拉取admin git pull origin admingit push --set-upstream origin master 设定 push默认分支关联本地仓库和远程仓库&#123;clone下来无法推送，需要关联 ssh -T git@gitee.com 查看是否关联成功&#125;添加远程仓库git remote add origin git@gitee.com:good_working&#x2F;teamwork_pracitce.git git remote add origin git@github.com:BrianLSH&#x2F;VueLearning.git关联了但是还不识别 需要用此命令git pull origin master --allow-unrelated-histories第一次本地无代码不用加后缀,如果有需要加上(https:&#x2F;&#x2F;blog.csdn.net&#x2F;lindexi_gd&#x2F;article&#x2F;details&#x2F;52554159) 撤销修改 1234567891011没有git add的，git checkout -- file可以丢弃工作区的修改：命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。总之，就是让这个文件回到最近一次git commit或git add时的状态。git add后的，git reset HEAD &lt;file&gt;可以把暂存区的修改撤销掉（unstage）, 重新放回工作区：如果再要放弃工作区的修改，接着用git checkout --file 文件删除 12git add&#x2F;rm &lt;file&gt; 删除文件git checkout --file 恢复","tags":[{"name":"tools git","slug":"tools-git","permalink":"http://yoursite.com/tags/tools-git/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"git","slug":"工具/git","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/git/"}]},{"title":"JavaScript-基础","date":"2015-03-24T16:00:00.000Z","path":"wiki/JavaScript-数据基础/","text":"js 基础知识及原理ES 6为止,7种类型1234567数值（number）：整数和小数（比如1和2.2）字符串（string）：文本（比如Everybody Loves Eileen）。布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假）undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值null：表示空值，即此处的值为空对象（object）：各种值组成的集合Symbol：独一无二的值，可以保证不会与其他属性名产生冲突 内置的类型识别方法123typeof 运算符instanceof 运算符Object.prototype.toString.call() 堆和栈123456789101112131415值类型：string number boolean null undefined 简单数据类型 存放的栈区(栈内存、变量对象), 属性名=属性值引用类型数组、对象、函数对象 属性名=内存地址，指向堆区，堆内存空间两种类型的复制与传递值类型相当于copy, 互不影响, 引用类型操作的是指向内存的地址,相互影响函数参数的引用传递及值传递,如果实参是值类型,会复制一个值类型的副本给函数,不会影响原来的传递参数如果是 引用类型,传递只是引用类型的一个地址值,在函数内部操作参数对应的引用对象会影响到传递的参数 事件循环机制EventLoop12345678910111213javascript 代码是队列的形式一个个进行执行的,同一时间只能执行一段代码队列数据结构:js单线程,为什么是单线程？ 执行线程和ui现成互斥同步任务 赋值操作、循环、分支语句等异步任务: dom事件、ajax、bom的一下apijs事件循环机制：---js的执行引擎的主线程从任务队列中获取任务执行---如果任务是异步的,那么运行到异步任务时,异步任务就退出主线程,主线程进行下一个任务的获取处理---如果异步任务完成, 就插入到任务队列的末尾,等待主线程处理 执行上下文(函数)栈的数据结构12345栈的数据结构:先进后出 栈顶push 栈低popEC:函数执行环境(或者执行上下文) Execution ContextECS: 执行环境栈 Execution Context StackVo变量对象:scope chain 作用域链 执行上下文的执行栈123456789js执行在单线程上,所有的代码都是排队执行一开始浏览器执行全局的代码时,首先创建全局的执行上下文,压入执行栈的顶部每当进入一个函数的执行,就会创建函数的执行上下文,并且把它压入执行栈的顶部,当前函数执行完成后,当前函数的执行上下文出栈,并等待垃圾回收浏览器的js执行引擎总是访问栈顶的执行上下文全局上下文只有唯一的一个,他在浏览器关闭时候出栈 执行栈的压栈出栈过程:1234567891011121314四个函数f1 f2-&gt;f3-&gt;f4 f1() f2()f1的EC--&gt;压入执行环境栈f2的EC-&gt;压入执行环境栈 在f1之上f3的EC-&gt;压入执行环境栈, f2之上f4的EC-&gt;压入执行环境栈, f3之上f1执行完成-&gt; f1的ec出栈f4执行完成-&gt; f4的ec出栈f3执行完成-&gt; f3的ec出栈f2执行完成-&gt; f2的ec出栈进栈 1234 出栈 4321最后只剩下全局的EC 浏览器关闭出栈 执行栈的压栈出栈过程:12345创建----&gt;执行----&gt;销毁创建：生成变量对象 建立作用域链 确定this指向执行: 变量赋值 函数引用 执行其他代码执行完毕, 等待垃圾回收你 函数的作用域js的解释和执行阶段12解释: 词法分析,语法分析,作用域规则确定执行阶段:创建执行上下文, 执行函数代码, 垃圾回收 作用域1234作用域: 变量声明的区域 也就是变量和函数的可访问范围函数的参数 只能在内部访问，局部变量没有 var 全局 任何地方可以访问 变量提升作用域链1作用域链是一个数组,由内向外逐级查找,直到找到同名标识符,找到不在遍历,找不到报错 垃圾回收机器原型链不确定参数 处理 最大最小值参数太多怎么办？ 封装成一个对象传递 常用数组方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131Array.map()此方法是将数组中的每个元素调用一个提供的函数，结果作为一个新的数组返回，并没有改变原来的数组let arr = [1, 2, 3, 4, 5] let newArr = arr.map(x =&gt; x*2) //arr= [1, 2, 3, 4, 5] 原数组保持不变 //newArr = [2, 4, 6, 8, 10] 返回新数组 Array.forEach()此方法是将数组中的每个元素执行传进提供的函数，没有返回值，注意和map方法区分let arr = [1, 2, 3, 4, 5] num.forEach(x =&gt; x*2) // arr = [1, 2, 3, 4, 5] 数组改变,注意和map区分 Array.filter()此方法是将所有元素进行判断，将满足条件的元素作为一个新的数组返回let arr = [1, 2, 3, 4, 5] const isBigEnough = value =&gt; value &gt;= 3 let newArr = arr.filter(isBigEnough ) //newNum = [3, 4, 5] 满足条件的元素返回为一个新的数组 Array.every()此方法是将所有元素进行判断返回一个布尔值，如果所有元素都满足判断条件，则返回true，否则为false：let arr = [1, 2, 3, 4, 5] const isLessThan4 = value =&gt; value &lt; 4 const isLessThan6 =&gt; value =&gt; value &lt; 6 arr.every(isLessThan4 ) //false arr.every(isLessThan6 ) //true Array.some() 此方法是将所有元素进行判断返回一个布尔值，如果存在元素都满足判断条件，则返回true，若所有元素都不满足判断条件，则返回false：let arr= [1, 2, 3, 4, 5] const isLessThan4 = value =&gt; value &lt; 4 const isLessThan6 = value =&gt; value &gt; 6 arr.some(isLessThan4 ) //true arr.some(isLessThan6 ) //false Array.reduce() 此方法是所有元素调用返回函数，返回值为最后结果,传入的值必须是函数类型：let arr = [1, 2, 3, 4, 5] const add = (a, b) =&gt; a + b let sum = arr.reduce(add) //sum = 15 相当于累加的效果 与之相对应的还有一个 Array.reduceRight() 方法，区别是这个是从右向左操作的 Array.push() 此方法是在数组的后面添加新加元素，此方法改变了数组的长度： Array.pop() 此方法在数组后面删除最后一个元素，并返回数组，此方法改变了数组的长度：let arr = [1, 2, 3, 4, 5] arr.pop() console.log(arr) //[1, 2, 3, 4] console.log(arr.length) //4 Array.shift() 此方法在数组后面删除第一个元素，并返回数组，此方法改变了数组的长度：let arr = [1, 2, 3, 4, 5] arr.shift() console.log(arr) //[2, 3, 4, 5] console.log(arr.length) //4 Array.unshift() 此方法是将一个或多个元素添加到数组的开头，并返回新数组的长度：let arr = [1, 2, 3, 4, 5] arr.unshift(6, 7) console.log(arr) //[6, 7, 1, 2, 3, 4, 5] console.log(arr.length) //7 Array.isArray() 判断一个对象是不是数组，返回的是布尔值 Array.concat() 此方法是一个可以将多个数组拼接成一个数组：let arr1 = [1, 2, 3] arr2 = [4, 5] let arr = arr1.concat(arr2) console.log(arr)//[1, 2, 3, 4, 5] Array.toString() 此方法将数组转化为字符串：let arr = [1, 2, 3, 4, 5]; let str = arr.toString() console.log(str)// 1,2,3,4,5 Array.join() 此方法也是将数组转化为字符串：let arr = [1, 2, 3, 4, 5]; let str1 = arr.toString() let str2 = arr.toString(&#x27;,&#x27;) let str3 = arr.toString(&#x27;##&#x27;) console.log(str1)// 12345 console.log(str2)// 1,2,3,4,5 console.log(str3)// 1##2##3##4##5 通过例子可以看出和toString的区别，可以设置元素之间的间隔~ Array.splice(开始位置， 删除的个数，元素)万能方法，可以实现增删改：let arr = [1, 2, 3, 4, 5]; let arr1 = arr.splice(2, 0 &#x27;haha&#x27;) let arr2 = arr.splice(2, 3) let arr1 = arr.splice(2, 1 &#x27;haha&#x27;) console.log(arr1) //[1, 2, &#x27;haha&#x27;, 3, 4, 5]新增一个元素 console.log(arr2) //[1, 2] 删除三个元素 console.log(arr3) //[1, 2, &#x27;haha&#x27;, 4, 5] 替换一个元素 常用字符串方法背啊背我骄傲的心12345678910111213141516171819字符串方法 拼接 concat 截取 str.slice(1, 5) 1-5之间 str.substring(1,5) 包含第一个 不包含最后一个str.substr(2, 6);//从下标2开始往后数6个数 不包括第一个下标str.indexOf(&quot;abc&quot;) 含返回第一位的下标，停止查找，如没有返回 -1str.lastIndexOf(&quot;abc&quot;) 含返回第一位的下标，停止查找，如没有返回 -1大小写转换 toUpperCase toLowerCase重复字符串 repeat字符串转数组 split()字符串查找 charAt 返回指定位置的字符串str.replace(&quot;天天&quot;, &quot;**&quot;); 只替换一次 str.match(&quot;天天&quot;); 返回查找到的字符串 没有 nullstr.search(&quot;天天&quot;) 找到返回下标 找不到返回 -1str.startsWith(&quot;he&quot;); 以he开始 布尔值str.endsWith(&quot;world&quot;); 以world 结束 布尔值str.includes(&quot;o&quot;); 布尔值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177charAt()查找返回指定位置的字符 var str = &quot;abcdefg&quot;; var s = str.charAt(5); // 下标为5的字符 console.log(s);//f charcodeAt()查找返回指定位置字符的unicdoe码 var str = &quot;abcdefg&quot;; var s = str.charCodeAt(5); // 下标为5的字符的unicdoe码 console.log(s);//102concat()连接字符串 var str = &quot;abc&quot;; var str1 = str.concat(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;dsdafsdafsad&quot;); console.log(str1);//abcabcdsdafsdafsad slice()字符串截取 var str = &quot;abcdefghijklm&quot;; var str1 = str.slice(1, 5); console.log(str1);//bcde 详细用法请参考数组用法。split()将字符串转换为数组 var str = &quot;abcdefg&quot; var str1 =str.split(&quot;&quot;) console.log(str);//abcdefg console.log(str1)//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;] substring()字符串截取 var str = &quot;abcdefghijklm&quot;; var str1 = str.substring(1, 9);//从下边1开始到下边9结束不包括下标9那一项 var str2 = str.substring(9, 1); console.log(str1);//bcdefghi console.log(str2);//bcdefghi substr()字符串截取 var str = &quot;abcdefghijklm&quot;; var str1 = str.substr(2, 6);//从下标2开始往后数6个数 console.log(str1);//cdefgh indexOf()遍历字符串查找包含第一个参数的字符串，如包含返回第一位的下标，停止查找，如没有返回 -1。第二个参数表示从此下标开始查找。 var str = &quot;abcdefabcjklm&quot;; var a = str.indexOf(&quot;abc&quot;) var b = str.indexOf(&quot;abc&quot;, 1); console.log(a);//0 console.log(b);//6 toUpperCase转大写var str = &quot;aAbBcCdD&quot;; console.log(str.toUpperCase());//AABBCCDDtoLowerCase转小写 var str = &quot;aAbBcCdD&quot;; console.log(str.toLowerCase());//aabbccddreplace()替换字符串只能匹配一次 var str = &quot;今天天天天气好好&quot;; var str1 = str.replace(&quot;天天&quot;, &quot;**&quot;); console.log(str1);//今**天天气好好 match()查找字符串 var str = &quot;今天天气好好&quot;; var result = str.match(&quot;天天&quot;); console.log(result);//[&quot;天天&quot;, index: 1, input: &quot;今天天气好好&quot;, groups: undefined] search()查找字符串返回下标var str = &quot;今天天气天天好好&quot;; var result = str.search(&quot;天天&quot;); console.log(result);//1 startsWith 判定一个字符串是否以另一个字符串开头 复制代码 var str = &quot;hello world&quot;; var result = str.startsWith(&quot;he&quot;); console.log(result)//true //当为两个参数时，第二个表示开始位数。 var result = str.startsWith(&quot;he&quot;,1); console.log(result)//flase复制代码endsWith判定一个字符串是否以另一个字符串结尾复制代码 var str = &quot;hello world&quot;; //检测尾部 var result = str.endsWith(&quot;world&quot;); console.log(result);//true //检测指定位置是否以指定字符结尾 var result1 = str.endsWith(&quot;wo&quot;, 8); console.log(result1)//true复制代码includes检测是否包含指定字符串 var str = &quot;hello world&quot;; var result = str.includes(&quot;o&quot;); console.log(result);//true var result1 = str.includes(&quot;o&quot;, 8); console.log(result1);//false repeat 重复字符串var str =&quot;haha&quot; var str1 = str.repeat(3); console.log(str1)//hahahahahaha","tags":[{"name":"JavaScript 基础知识 数据类型","slug":"JavaScript-基础知识-数据类型","permalink":"http://yoursite.com/tags/JavaScript-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"基础","slug":"JavaScript/基础","permalink":"http://yoursite.com/categories/JavaScript/%E5%9F%BA%E7%A1%80/"}]}],"categories":[{"name":"优化","slug":"优化","permalink":"http://yoursite.com/categories/%E4%BC%98%E5%8C%96/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"基础","slug":"Vue/基础","permalink":"http://yoursite.com/categories/Vue/%E5%9F%BA%E7%A1%80/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"},{"name":"命令","slug":"Linux/命令","permalink":"http://yoursite.com/categories/Linux/%E5%91%BD%E4%BB%A4/"},{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"},{"name":"框架","slug":"PHP/框架","permalink":"http://yoursite.com/categories/PHP/%E6%A1%86%E6%9E%B6/"},{"name":"Laravel","slug":"PHP/框架/Laravel","permalink":"http://yoursite.com/categories/PHP/%E6%A1%86%E6%9E%B6/Laravel/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"基础","slug":"JavaScript/基础","permalink":"http://yoursite.com/categories/JavaScript/%E5%9F%BA%E7%A1%80/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/categories/mysql/"},{"name":"基础","slug":"mysql/基础","permalink":"http://yoursite.com/categories/mysql/%E5%9F%BA%E7%A1%80/"},{"name":"基础","slug":"PHP/基础","permalink":"http://yoursite.com/categories/PHP/%E5%9F%BA%E7%A1%80/"},{"name":"Es6","slug":"Es6","permalink":"http://yoursite.com/categories/Es6/"},{"name":"基础","slug":"Es6/基础","permalink":"http://yoursite.com/categories/Es6/%E5%9F%BA%E7%A1%80/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"},{"name":"基础","slug":"CSS/基础","permalink":"http://yoursite.com/categories/CSS/%E5%9F%BA%E7%A1%80/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"git","slug":"工具/git","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/git/"}],"tags":[{"name":"性能优化 浏览器渲染 缓存","slug":"性能优化-浏览器渲染-缓存","permalink":"http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93-%E7%BC%93%E5%AD%98/"},{"name":"Vue key","slug":"Vue-key","permalink":"http://yoursite.com/tags/Vue-key/"},{"name":"linux基础 常用命令","slug":"linux基础-常用命令","permalink":"http://yoursite.com/tags/linux%E5%9F%BA%E7%A1%80-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"name":"PHP 框架 Laravel","slug":"PHP-框架-Laravel","permalink":"http://yoursite.com/tags/PHP-%E6%A1%86%E6%9E%B6-Laravel/"},{"name":"JavaScript 基础知识 跨域","slug":"JavaScript-基础知识-跨域","permalink":"http://yoursite.com/tags/JavaScript-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%B7%A8%E5%9F%9F/"},{"name":"JavaScript 基础知识 jq vue","slug":"JavaScript-基础知识-jq-vue","permalink":"http://yoursite.com/tags/JavaScript-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-jq-vue/"},{"name":"JavaScript 基础知识 闭包","slug":"JavaScript-基础知识-闭包","permalink":"http://yoursite.com/tags/JavaScript-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E9%97%AD%E5%8C%85/"},{"name":"Vue 单页面应用 优缺点","slug":"Vue-单页面应用-优缺点","permalink":"http://yoursite.com/tags/Vue-%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8-%E4%BC%98%E7%BC%BA%E7%82%B9/"},{"name":"Vue 样式穿透 深度作用域","slug":"Vue-样式穿透-深度作用域","permalink":"http://yoursite.com/tags/Vue-%E6%A0%B7%E5%BC%8F%E7%A9%BF%E9%80%8F-%E6%B7%B1%E5%BA%A6%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"JavaScript 基础知识 函数 箭头函数","slug":"JavaScript-基础知识-函数-箭头函数","permalink":"http://yoursite.com/tags/JavaScript-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%87%BD%E6%95%B0-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"},{"name":"Vue 基础知识 项目打包","slug":"Vue-基础知识-项目打包","permalink":"http://yoursite.com/tags/Vue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/"},{"name":"mysql基础 远程连接","slug":"mysql基础-远程连接","permalink":"http://yoursite.com/tags/mysql%E5%9F%BA%E7%A1%80-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"},{"name":"Vue NextTick","slug":"Vue-NextTick","permalink":"http://yoursite.com/tags/Vue-NextTick/"},{"name":"Vue 动态路由","slug":"Vue-动态路由","permalink":"http://yoursite.com/tags/Vue-%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/"},{"name":"Vue 双向绑定","slug":"Vue-双向绑定","permalink":"http://yoursite.com/tags/Vue-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"},{"name":"JavaScript 基础知识 面向对象 对象创建","slug":"JavaScript-基础知识-面向对象-对象创建","permalink":"http://yoursite.com/tags/JavaScript-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/"},{"name":"Vue 基础知识 插件使用","slug":"Vue-基础知识-插件使用","permalink":"http://yoursite.com/tags/Vue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"php 基础","slug":"php-基础","permalink":"http://yoursite.com/tags/php-%E5%9F%BA%E7%A1%80/"},{"name":"Vue $route $router","slug":"Vue-route-router","permalink":"http://yoursite.com/tags/Vue-route-router/"},{"name":"Vue 基础知识 路由跳转","slug":"Vue-基础知识-路由跳转","permalink":"http://yoursite.com/tags/Vue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC/"},{"name":"Vue 基础知识 v-if v-show","slug":"Vue-基础知识-v-if-v-show","permalink":"http://yoursite.com/tags/Vue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-v-if-v-show/"},{"name":"Vue 基础知识 keep-alive","slug":"Vue-基础知识-keep-alive","permalink":"http://yoursite.com/tags/Vue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-keep-alive/"},{"name":"Vue 基础知识 watch computed","slug":"Vue-基础知识-watch-computed","permalink":"http://yoursite.com/tags/Vue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-watch-computed/"},{"name":"Vue 基础  脚手架 基础","slug":"Vue-基础-脚手架-基础","permalink":"http://yoursite.com/tags/Vue-%E5%9F%BA%E7%A1%80-%E8%84%9A%E6%89%8B%E6%9E%B6-%E5%9F%BA%E7%A1%80/"},{"name":"Es6  本地存储 使用场景","slug":"Es6-本地存储-使用场景","permalink":"http://yoursite.com/tags/Es6-%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"},{"name":"Es6 基础  Promise","slug":"Es6-基础-Promise","permalink":"http://yoursite.com/tags/Es6-%E5%9F%BA%E7%A1%80-Promise/"},{"name":"JavaScript 基础知识 this","slug":"JavaScript-基础知识-this","permalink":"http://yoursite.com/tags/JavaScript-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-this/"},{"name":"Es6 基础  Promise 回调地狱 await async","slug":"Es6-基础-Promise-回调地狱-await-async","permalink":"http://yoursite.com/tags/Es6-%E5%9F%BA%E7%A1%80-Promise-%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1-await-async/"},{"name":"PHP Laravel 命令","slug":"PHP-Laravel-命令","permalink":"http://yoursite.com/tags/PHP-Laravel-%E5%91%BD%E4%BB%A4/"},{"name":"Vue 基础知识 vue-loader","slug":"Vue-基础知识-vue-loader","permalink":"http://yoursite.com/tags/Vue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-vue-loader/"},{"name":"Vue 跨域 接口代理","slug":"Vue-跨域-接口代理","permalink":"http://yoursite.com/tags/Vue-%E8%B7%A8%E5%9F%9F-%E6%8E%A5%E5%8F%A3%E4%BB%A3%E7%90%86/"},{"name":"Vue 基础知识 VueX","slug":"Vue-基础知识-VueX","permalink":"http://yoursite.com/tags/Vue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-VueX/"},{"name":"Vue 基础知识 组件传值","slug":"Vue-基础知识-组件传值","permalink":"http://yoursite.com/tags/Vue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"},{"name":"Vue 基础知识 date","slug":"Vue-基础知识-date","permalink":"http://yoursite.com/tags/Vue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-date/"},{"name":"Vue 基础知识 生命周期","slug":"Vue-基础知识-生命周期","permalink":"http://yoursite.com/tags/Vue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"name":"CSS基础 CSS案例","slug":"CSS基础-CSS案例","permalink":"http://yoursite.com/tags/CSS%E5%9F%BA%E7%A1%80-CSS%E6%A1%88%E4%BE%8B/"},{"name":"CSS基础 行高","slug":"CSS基础-行高","permalink":"http://yoursite.com/tags/CSS%E5%9F%BA%E7%A1%80-%E8%A1%8C%E9%AB%98/"},{"name":"CSS基础 选择器","slug":"CSS基础-选择器","permalink":"http://yoursite.com/tags/CSS%E5%9F%BA%E7%A1%80-%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"Vue  基础知识 slot插槽","slug":"Vue-基础知识-slot插槽","permalink":"http://yoursite.com/tags/Vue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-slot%E6%8F%92%E6%A7%BD/"},{"name":"tools git","slug":"tools-git","permalink":"http://yoursite.com/tags/tools-git/"},{"name":"JavaScript 基础知识 数据类型","slug":"JavaScript-基础知识-数据类型","permalink":"http://yoursite.com/tags/JavaScript-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}]}